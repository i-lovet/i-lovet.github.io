---
标题: 与运行时交互
aliases: 
tags:
  - 技术/iOS/Runtime
创建时间: 2025-07-18 12:07
修改时间: 2025-08-06 22:38
---
OC程序与运行时系统交互 有三个确切的层次：

- 通过 OC源代码
- 通过Foundation框架的NSObject类中定义的方法
- 通过直接调用运行时函数

**OC源码 (Objective-C Source Code)**

       绝大多数情况下，运行时系统自动地在幕后工作。我们仅仅通过写然后编译OC源代码使用到它。

       当你编译包含了OC类和方法的代码时，编译器通过执行语言的动态特征，创建数据结构和函数调用。数据结构在类和类目定义，协议的声明中发现并采集信息；这些信息包括_The Objective-C Programming Language 中_Defining a Class and Protocols 一节中介绍的类和协议对象；也包括方法选择器，实例变量模版，还有其它一些从源代码中提取出来的信息。主要的运行时函数是发送消息函数，在Messaging(消息发送)中有介绍。在源代码中有发送消息语句时被调用。

**NSObject 方法 (NSObject Methods)**

       Cocoa中的大多数对象都是子类化NSObject类得到的，所以大多数对象都继承NSObject定义的方法。（值得注意的例外是NSProxy类，在消息转发(Message Forwarding)中有更多信息。）因此，它的方法创建的行为是每个实例，每个类对象固有的。然而，在小部分的例子里，NSObject类仅仅是为something如何被做定义了一个模版，并没有提供所有需要的代码。

       例如，NSObject类定义了一个description的实例方法，用来返回一个描述类的内容的字符串。这主要是用来调试的方法－GDB print-object 命令打印的字符串就是从这个方法得到的。由于，NSObject中这个方法的实现并不知道类里面包含什么内容，所以它返回的是一个带对象的名字和地址的字符串。通过子类化NSObject，然后实现这个方法可以返回更多的细节内容。例如，Foundation中的NSArray类返回的是一个它包含的对象的描述列表。

       一些NSObject的方法只是简单的向运行时系统查询一下信息。这些方法一般都允许对象去进行内省。比如，class方法要求一个对象标识它的所属类；isKindOfClass:和isMemberOfClass:，检测一个对象在继承层级结构中的位置；respondsToSelector:,标识一个对象是否能接收一条指定的消息；conformsToProtocol:，标识一个对象是否请求要实现定义在一个指定的协议中的方法；methodForSelector:，提供一个方法的实现的地址。像这些方法，给了一个对象去内省它自己的能力。

**运行时函数(Runtime Functions)**

       运行时系统是一个动态共享库，有一个公共的借口，这个借口由放置在/usr/include/objc这个路径中的头文件中的一系列函数和数据结构组成。
