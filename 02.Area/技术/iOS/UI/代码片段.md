---
标题: 代码片段
aliases: 
tags:
  - 技术/iOS/UI
创建时间: 2025-07-18 12:07
修改时间: 2025-08-06 22:33
---
### 1、截图

```Objective-C
// 给定一个图形上下文使它为当前 上下文        
UIGraphicsBeginImageContext(self.view.bounds.size);
// 获取当前上下文
CGContextRef context = UIGraphicsGetCurrentContext();
// 要截取的大小
CGContextSaveGState(context);
UIRectClip(self.clipView.frame);
// 在谁上面截取，渲染receiver上sublayers到指定的上下文
[self.imageView.layer renderInContext:context];
// 获取截取的图片
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();
// 保存到相册
UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil);
// 从栈顶移除图形上下文
UIGraphicsEndImageContext();
```

### 2、存储到相册

```Objective-C
[imageView setImageWithURL:[NSURL URLWithString:model.pic]placeholder:nil options:YYwebImage0ptionShowNetworkActivitycompletion:^(UIImage * Nullable image,NSURL * Nonnull urlYYWebImageFromType from, YYWebImageStage stage, NSError *Nullable error){
	NSLog(@"%@"，NSHomeDirectory());
	NSString *path = [[NSSearchPathForDirectoriesInDomains
		(NSDocumentDirectory,NSUserDomainMask,YES) lastobject] 
		stringByAppendingPathComponent: 
		[NSString stringWithFormat:@"%@.png", model.title]];
	NSData *data=[NSData alloclinitwith
	[UIImagePNGRepresentation(image) writeToFile: path atomically:YES];
}];
```

### 3、NSAttributedString 属性值翻译

```Objective-C
// 能够显示文本的控件，都有attributedString属性  
// NSAttributedString.h 中文本属性key的说明  
// 设置字体属性，默认值：字体：Helvetica(Neue) 字号：12
NSFontAttributeName
// 设置字体颜色，取值为 UIColor对象，默认值为黑色
NSForegroundColorAttributeNam
// 设置字体所在区域背景颜色，取值为 UIColor对象，默认值为nil, 透明色
NSBackgroundColorAttributeName
// 设置连体属性，取值为NSNumber 对象(整数)，0 表示没有连体字符，1 表示使用默认的连体字符
NSLigatureAttributeName
// 设定字符间距，取值为 NSNumber 对象（整数），正值间距加宽，负值间距变窄
NSKernAttributeName
// 设置删除线，取值为 NSNumber 对象（整数）
NSStrikethroughStyleAttributeName
// 设置删除线颜色，取值为 UIColor 对象，默认值为黑色
NSStrikethroughColorAttributeName
// 设置下划线，取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle中的值，与删除线类似
NSUnderlineStyleAttributeName
// 设置下划线颜色，取值为 UIColor 对象，默认值为黑色
NSUnderlineColorAttributeName
// 设置笔画宽度，取值为 NSNumber 对象（整数），负值填充效果，正值中空效果
NSStrokeWidthAttributeName
// 填充部分颜色，不是字体颜色，取值为 UIColor 对象
NSStrokeColorAttributeName
// 设置阴影属性，取值为 NSShadow 对象
NSShadowAttributeName
// 设置文本特殊效果，取值为 NSString 对象，目前只有图版印刷效果可用：
NSTextEffectAttributeName           
// 设置基线偏移值，取值为 NSNumber （float）,正值上偏，负值下偏 
NSBaselineOffsetAttributeName
// 设置字形倾斜度，取值为 NSNumber （float）,正值右倾，负值左倾
NSObliquenessAttributeName
// 设置文本横向拉伸属性，取值为 NSNumber （float）,正值横向拉伸文本，负值横向压缩文本
NSExpansionAttributeName
// 设置文字书写方向，从左向右书写或者从右向左书写
NSWritingDirectionAttributeName
// 设置文字排版方向，取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本
NSVerticalGlyphFormAttributeName
// 设置链接属性，点击后调用浏览器打开指定URL地址
NSLinkAttributeName
// 设置文本附件,取值为NSTextAttachment对象,常用于文字图片混排
NSAttachmentAttributeName
// 设置文本段落排版格式，取值为 NSParagraphStyle 对象
NSParagraphStyleAttributeName
```

### 4、TableCell 自适应高度，垂直方向连续

```Objective-C
- (void) layoutSubviews {
	[super layoutSubviews];
	hehe.constant = 100;//自适应高度
	// label1.text=text1;
	// label2.text=text2;
	//自适应高度还需要知道label的宽度
	label1.preferredMaxLayoutWidth = CGRectGetWidth( label1.frame);
	label2.preferredMaxLayoutWidth = cGRectGetWidth( label2.frame);
	//垂直的间隙约束 + label的高度 = 自适应的高度
}
```

### 5、手势冲突

```Objective-C
#pragma mark 手势识别器 协议方法:return YES,表示该手势允许跟其他手势共存。如果两个手势要互相共存，那么两个手势的代理方法的返回值都应该设为YES
- (B00L) gestureRecognizer: (UIGestureRecognizer *) gestureRecognizershouldRecognizeSimultaneouslyWithGestureRecognizer: (UIGestureRecognizer *) otherGestureRecognizer {
	return YES;
}
```

### 6、触摸事件的分发

```Objective-C
// 通过这个方法进行事件的分发
/** 
1: 循环遍历所有的子视图
2: 判断当前的触摸点，是否在某个子视图范围之内
3: 如果触摸点在这个视图的范围之内，那么就讲此视图作为返回值返回
4: 返回的对象最终接受事件，接受事件之后，调用touchesBegan做出响应
*/
/**
 * Description
 * @param point point description
 * @param event event description
 * 
 * @return 返回谁，谁就去响应事件
 */
- (UIView *) hitTest: (CGPoint) point withEvent: (UIEvent *) event {
  //遍历子视图
	/*
	for(UIView *subView in self.subviews) {
		// 判断点是不是在子视图范围之内
		GPoint p = [self convertPoint:point toView:subViewl;
		B00L isInside = [subView pointInside:p withEvent:event];
		if (isInside) {
			return [subView hitTest:p withEvent:event];
		}
	}
	// 代码走到这里，说明没有子视图或者当前触摸的点不在任何一个子视图上面
	return self;
	*/	  
	return [super hitTest:point withEvent:event];
}
```

### 7、点在范围内

```Objective-C
// 把view1上的点转换为view2坐标系上的点
CGPoint point = [view1convertPoint:[touch locationInView:view1] toView:view2];
// 判断同一坐标系内点是否在某视图的范围内  
CGRectContainsPoint(self.view.frame,[touch locationInView:self]);
// 判断两个rect1是否包含rect2
CGRectContainsRect(<#CGRect rect1#>, <#CGRect rect2#>)
// 判断两个frame是否相交
CGRectIntersectsRect(<#CGRect rect1#>, <#CGRect rect2#>)
// point是否在消息接受者范围内
inView = [self.view pointInside:point withEvent:event];
```

### 8、hidesNaOnTap,分享按钮

```Objective-C
navigationcontroller?.hidesBarsOnTap = true

let indexP = collectionView,indexPathsForVisibleItems()[0] as! NSIndexPath
let image = UIImage(named:arrlindexP.row】)
let VC = UIActivityViewController(activityItems: [image!l,applicationActivities: [])
VC.popoverPresentationController?,barButtonItem = sender as! UIBarButtonItem
presentViewController(Vc,animated:true,completion:nil)
```

### 9、地址，经纬度互编

```Objective-C
//由经纬度 -》地名
//由地名 -》经纬度
CLGeocoder *g = [[cLGeocoder alloc] init];
[g reverseGeocodeLocation:location completionHandler:^(NSArray *placemarks，NSError*error) {
	//不管编码成功或者失败，都会进来
	CLPlacemark *place=[placemarks lastObject】;
	NSLog(@"%@--%@--%@--%@--%@--%@--%@--%@--%@--%@--%@--%@--%@",
place.name,place.thoroughfare,place.subThoroughfare,place.locality,place.subLocality,place.administrativeArea,place.subAdministrativeArea,place.postalcode,place.IsOcountryCode,place.country,place.inlandWater,place.ocean,place.areasofInterest);
/** 
光谷软件园A10号--软件园东路1号--(null)--武汉市--洪山区--湖北省--(null)--(null)--CN--中国--(null)--(null)--(null)
*/
//位置 -》经纬度(有待查证)//[g geocodeAddressString:(NSString *)completionHandler:^(NSArray*placemarks，NSError *error){
```

### 10、ARC，MRC使用标记

```Objective-C
ARC、MRC的使用标记
对于某些我们不希望使用 ARC 的文件,例如第三方库源文件,可以在 ProjectSettings -> Build Phases 中设置
	-fno-objc-arc  标记源代码文件使用MRC
	-fobjc-arc     标记文件使用ARC
```

### 11、跳转 WiFi

#### 11.1 info配置文件中设置

在项目中的info.plist中添加 URL types 并设置一项URL Schemes为prefs，如下图:

![20250725161223.png](https://ol.1st.ddns-ip.net/d/public/20250806/raZqpD.webp?sign=1vlCT3PeHXoC8k6GSWVpc1TUJz5KZqM7NF-CE5EOXIo=:0)

#### 11.2 实现代码

```Objective-C
NSURL *url = [NSURL URLWithString:@"prefs:root=WIFI"];
if ([[UlApplication sharedApplication] canOpenURL:url]) {
	[[UlApplication sharedApplication] openURL:url];
}
```

### 12、汉字转码

```Objective-C
// 编码    
NSLog(@"%@",[@"f你还" stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding]);
// 解码   
NSLog(@"%@",[[@"f你还" stringByAddingPercentEscapesUsingEncoding: NSUTF8StringEncoding] stringByReplacingPercentEscapesUsingEncoding: NSUTF8StringEncoding]);


NSString *encodedstring=(NSString*) CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,(CFStringRef) urlstring, NULL, NULL, kCFStringEncodingUTF8);
// 这两种方法当urlstring里含有中文时URL编码是正确的,但是如果其中含有已转义的%等符号时，又会再次转义而导致错误，
// 查看方法2参数说明:
CFstringRef
CFURLCreatestringByAddingPercentEscapes(CFAllocatorRef allocator, CFstringRef originalstring, CFstringRef charactersToLeaveUnescaped, CFstringRef legalURLCharactersToBeEscaped, CFStringEncoding encoding);
// 因此做出修改，写出方法:
NSString *encodedstring = (NSString *) CFURLCreateStringByAddingPercentEscapes(
	kCFAllocatorDefault,
	(CFStringRef) urlstring,
	(CFStringRef) @"!$&'()*+,-./:;=?@_ ~%#[]"
	NULL,
	kCFStringEncodingUTF8);
```

### 13、多线程

#### 13.1、程序是怎么运行的

> [!tip] Tips
> 多线程  —> 线程  —> 进程

1. 进程：进程就是一个应用程序  （一个应用程序也可以有一个或多个进程）
2. 线程  
	1. 一个应用程序有且只有一个主线程
	2. 在单个程序中同时运行多个线程完成不同的工作，称为[多线程](http://baike.baidu.com/view/65706.htm)
3. 线程是占一定的内存  步能无节制的创建
4. 一般在主线程中操作UI
5. 一般多线程做数据加载


> [!warn] Tips
陷阱 ：多线程不是同时执行的，而是交替进行的 ，感觉上是同时在执行。

#### 13.2 iOS中多线程的使用

1. pThread  跨平台的基于C语言的 基本不使用
2. NSThread
	1. 创建线程  ，手动调用 [t start]
	2. 创建线程 ，直接帮一个入口方法 detachNewThread
	3. 隐式   [self  performSelectorInBackground:  with: ]
3. GCD
	1. Grand central dispatch ,ios4.0引入
	2. 派遣队列 ，获取队列的方式 三种
		1. 获取主队列 ：    dispatch_get_main_queue  (在主线程上执行的队列 ，串行队列)
		2. 获取全局队列 ： dispatch_get_gloabl_queue (并行队列)
		3. 自己创建队列 ： dispatch_queue_creat(参数1，参数2); 参数2 指定队列类型
		4. 变量类型 ： dispatch_queue_t 
			1. 串行队列 ： 只有一个出口 ，任务是依次执行的
			2. 并行队列 ：一次可以并发执行多个任务
	3. 执行方式(任务)，GCD 使用block添加任务
		1. 同步添加任务 sync  (会阻塞主线程 ，只会在主线程中执行)
		2. 异步添加任务 async （不会阻塞主线程，在其他线程中完成）
	4. 线程的死锁的问题
		1. 由于同步添加任务会阻塞主线程，然后将任务添加到队列中等待执行。只有的带主线程的队列中的任务完成之后，才能执行添加到队列中的同步任务，由于主线程又要等待同步任务任务执行完成才能完成主线程任务，导致线程一直阻塞，造成死锁。
			结论 ： 尽量少使用同步添加任务。
	5. CGD主要使用方式
		1. 并行队列中异步添加任务（dispatch_get_gloabl_queue）
		2. 回调主线程队列 (main_queue)  异步添加任务
4. **NSOperation** 和 **NSOperationQueue**
	1. **NSOperation**（操作）**ios2.0**   后来有对 **GCD** 进行了进一步的封装
	2. 抽象的类  使用的是其两个子类
		1. NSInvacationOperation    通过绑定方法来添加任务
		2. NSBlockOperation              block来添加任务
		3. OperationQueue （操作队列）
				增加任务后会默认开启多个线程来并发完成任务 (GCD 并发异步执行任务).如果我想让任务一个一个的依次执行 ，可以设置OperationQueue 的最大并发数，还可以通过添加操作依赖 (注意 ： 不要添加相互依赖)
  5. 常见的并发问题
	  三种： 
	1. 数据竞争问题 (线程安全)
	2. 线程死锁
	3. 当量的线程到内存容量不足

### 14、第三方框架

1. 网络请求
2. back手势
3. uikit延展
4. 滑动刷新
5. 异步加载网络图片

![20250725161252.png](https://ol.1st.ddns-ip.net/d/public/20250806/zgDK93.webp?sign=jz0A_xfjyrn6R6ehEaRy2GoN-NX36XHI5G4zGpoBVh4=:0)

### 15、http 内容类型对照

[http://tool.oschina.net/commons](http://tool.oschina.net/commons)
